name: 3_decode_atis

on:
  workflow_run:
    workflows: ["whisper_transcribe"]
    types:
      - completed

jobs:
  decode:
    runs-on: ubuntu-22.04

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Installer Python et dépendances
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y python3 python3-pip
          pip install requests

      - name: Générer ATIS format FMS complet
        env:
          METAR_API_TOKEN: ${{ secrets.METAR_API_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python3 <<'PYCODE'
          import re, os, sys, requests, subprocess

          input_file = "atis_tallinn.txt"
          output_file = "atis_tallinn_fms.txt"

          if not os.path.exists(input_file):
              print(f"⚠️ Fichier {input_file} introuvable")
              sys.exit(1)

          with open(input_file, "r", encoding="utf-8") as f:
              raw = f.read()

          # --- Fonction pour convertir nombres écrits en chiffres ---
          num_words = {
              'zero': '0', 'one': '1', 'two': '2', 'three': '3', 'four': '4',
              'five': '5', 'six': '6', 'seven': '7', 'eight': '8', 'nine': '9',
              'ten': '10', 'eleven': '11', 'twelve': '12'
          }

          def words_to_number(text):
              def repl(m):
                  return ''.join(num_words.get(word.lower(), word) for word in m.group(0).split())
              # remplace tous les nombres écrits par des chiffres
              return re.sub(r'\b(?:' + '|'.join(num_words.keys()) + r')(?:\s(?:' + '|'.join(num_words.keys()) + r'))*\b', repl, text, flags=re.IGNORECASE)

          clean_text = words_to_number(raw)

          # --- Fonctions utilitaires pour extraction ---
          def extract(pattern, text, default="XXX"):
              match = re.search(pattern, text, re.IGNORECASE)
              return match.group(1).strip() if match else default

          def fetch_metar():
              token = os.environ.get("METAR_API_TOKEN")
              if not token:
                  return {}
              try:
                  url = f"https://avwx.rest/api/metar/EETN?options=info&format=json&token={token}"
                  r = requests.get(url, timeout=10)
                  if r.status_code == 200:
                      data = r.json()
                      return {
                          "wind_dir": int(data.get("wind_direction", {}).get("value", 0)),
                          "wind_speed": int(data.get("wind_speed", {}).get("value", 0)),
                          "visibility": int(data.get("visibility", {}).get("value", 0)),
                          "altimeter": int(data.get("altimeter", {}).get("value", 0)),
                          "temperature": int(data.get("temperature", {}).get("value", 0)),
                          "dewpoint": int(data.get("dewpoint", {}).get("value", 0))
                      }
              except:
                  pass
              return {}

          def validate(data, metar):
              try:
                  if metar:
                      # vent
                      if data["wind"] != "XXX":
                          dir_deg, speed = map(int, re.findall(r'\d+', data["wind"]))
                          if abs(dir_deg - metar["wind_dir"]) > 20 or abs(speed - metar["wind_speed"]) > 10:
                              data["wind"]="XXX"
                      # visibilité
                      if data["visibility"] != "XXX":
                          vis = int(re.findall(r'\d+', data["visibility"])[0])
                          if abs(vis - metar["visibility"]) > 2:
                              data["visibility"]="XXX"
                      # temp/dew
                      if data["temperature"] != "XXX":
                          at = int(data["temperature"])
                          dp = int(data["dewpoint"])
                          if abs(at - metar["temperature"]) > 3 or abs(dp - metar["dewpoint"]) > 3:
                              data["temperature"]="XXX"; data["dewpoint"]="XXX"
                      # QNH
                      if data["qnh"] != "XXX":
                          if abs(int(data["qnh"]) - metar["altimeter"]) > 5:
                              data["qnh"]="XXX"
              except:
                  for key in ["wind","visibility","temperature","dewpoint","qnh"]:
                      data[key]="XXX"
              return data

          # --- Extraire les infos ---
          atis_letter = extract(r"information\s+([A-Z])", clean_text)
          atis_time = extract(r"time\s+(\d{3,4})", clean_text)

          # vent
          wind_dir = extract(r"wind.*?(\d{1,3})\s*degrees", clean_text)
          wind_speed = extract(r"wind.*?(\d{1,3})\s*knots", clean_text)
          wind = f"{wind_dir}°{wind_speed}KT" if wind_dir!="XXX" and wind_speed!="XXX" else "XXX"

          # visibilité km
          visibility = extract(r"visibility.*?(\d+)", clean_text)
          visibility = f"{visibility}KM" if visibility!="XXX" else "XXX"

          # nuages
          cloud_matches = re.findall(r"(overcast|broken|few|scattered|bkn|sct|ovc)[ ,]*(\d+)[ ]*feet", clean_text, re.IGNORECASE)
          clouds = " ".join([f"{m[0].upper()} {m[1]}" for m in cloud_matches]) if cloud_matches else "XXX"

          # piste
          runway = extract(r"runway\s+(\d+)", clean_text)
          rwy_cond_match = re.search(r"touchdown.*?(\d+)[^\d]+midpoint.*?(\d+)[^\d]+stop end.*?(\d+)", clean_text, re.IGNORECASE)
          rwy_cond = f"TDZ {rwy_cond_match.group(1)}/MID {rwy_cond_match.group(2)}/END {rwy_cond_match.group(3)}" if rwy_cond_match else "XXX"

          # température / dew
          temperature = extract(r"temperature[, ]+(\d+)", clean_text)
          dewpoint = extract(r"dew point[, ]+(\d+)", clean_text)

          # QNH
          qnh = extract(r"q and h\s*(\d+)", clean_text)
          qnh_hpa = f"{qnh} HPA" if qnh!="XXX" else "XXX"

          # --- Validation METAR ---
          metar_data = fetch_metar()
          data = {"wind": wind, "visibility": visibility, "temperature": temperature, "dewpoint": dewpoint, "qnh": qnh}
          data = validate(data, metar_data)
          qnh_hpa = f"{data['qnh']} HPA" if data['qnh']!="XXX" else "XXX"

          # --- Construire message FMS ---
          fms_text = (
              f"EETN ATIS INFO {atis_letter} {atis_time}Z. "
              f"{data['wind']} {data['visibility']} {clouds} "
              f"RWY {runway} IN USE. "
          )
          if rwy_cond!="XXX":
              fms_text += f"RWY COND {rwy_cond}. "
          fms_text += f"TEMP {data['temperature']}/{data['dewpoint']}C. "
          fms_text += f"A{qnh_hpa}. "

          # --- Écrire fichier ---
          with open(output_file, "w", encoding="utf-8") as f:
              f.write(fms_text + "\n")

          print("✅ ATIS FMS complet généré :", output_file)
          print(fms_text)

          # --- Commit et push ---
          subprocess.run(["git", "config", "user.name", "github-actions"])
          subprocess.run(["git", "config", "user.email", "actions@github.com"])
          subprocess.run(["git", "add", output_file])
          subprocess.run(["git", "commit", "-m", f"Mise à jour ATIS FMS ({atis_time}Z)"], check=False)
          subprocess.run(["git", "push", "origin", "main"], check=False)
          PYCODE
